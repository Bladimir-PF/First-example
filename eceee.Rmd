---
title: "Second exercise"
author: "Geraldo B. Padilla F."
date: "9/8/2021"
output:
  html_document: default
  word_document: default
---

1. Exercise 1 using R

Load packages

```{r, warning=FALSE, message=FALSE}
library("easypackages")
paq <- c('psqf6246stat6516','e1071','lubridate', 'mosaic', 'ggformula', 'paramtest', 'pwr', 'ggplot2', 'nlme', 'dplyr', 'dbplyer', 'knitr', 'dplyr', 'dbplyr')
libraries(paq)
```

Create some variables and a database. Then, run some descriptive statistics to explore the database.
We can use different commands to create data depending on the type of variables we need. For instance:

*`runif`: random rational numbers. By default it yields values between 0 a 1, but we can increase the range of expected values. e.g. `runif(100, min=0, max=2)`

*`sample`: random integer numbers, e.g. `sample(18: 65, 100, replace = T)`

*`rnorm`: random numbers clustered around a mean and sd, e.g. `rnorm(100, mean = 1500, sd= 100)`

Let us use `sample` to create some variables.

```{r}
age <- sample(250: 650, 150, replace = T)
income <- sample(250: 1500, 6000, replace = T)
SEG <- sample(250: 1, 4, replace = T)
data1 <- data.frame(age, income, SEG)



seg1 = group_by(data1, SEG)
summarise(seg1, mean(age))

data1%>%
  group_by(SEG)%>%
  summarise(mean(age))

df_stats(~age, data = data1, mean, sd, var)

cor_apa
  
```

If we want to enhance the reproducibility of our work, we can set a seed into the randomization. Thus, we will get always the same random numbers.

```{r}
set.seed(1234)
age <- sample(18: 65, 250, replace = T)

set.seed(1234)
income <- sample(750: 1500, 250, replace = T)

set.seed(1234)
SEG <- sample(1: 4, 250, replace = T)

data <- data.frame(age, income, SEG)
```

Now, visualize the database

```{r}
View(data) #you will see the rows and columns that make up your database
summary(data) #you will see some descriptive statistics of the variables in your database 
str(data) #you will see the structure of your database (variables, scale and some values)
```

After exploring the database as a unit, we can see the distribution of the variables.

```{r, echo=FALSE}
gf_histogram(~income, data = data, bins = 50) %>%
  gf_labs(x = 'Incomes')

gf_boxplot(~income, data = data, fill = 'skyblue')%>%
  gf_labs(x = 'Incomes')

gf_histogram(~income, data = data, bins = 50)%>%
  gf_boxplot(12 ~ income, data = data, fill = 'blue', width= 1)%>%
  gf_labs(x= 'Income', y= 'Frequency')

```


the mean is the only value we can use to 'balance' the deviations.


histogram(income)
View(income)



gf_histogram(~age, income)
density(age)
```




2. Varying N (total sample size) and Cohen's d

2.1 Run the function below as it is

```{r}

```


```{r}
power_one_source(Nmin = 50, # min sample size 
                 Nmax = 200, # max sample size
                 Nincrement = 50,  # increment in sample size
                 dmin = .2,  # min efefct size
                 dmax = .5,  # max effect size
                 dincrement = .1, # increment in effect size
                 n.iter = 1000) # number of iterations 
```

  
# 2) keep the effect size as it is and reduce the sample the effect size

# 3) keep the effect size as it is and increase the sample the effect size

# 4) repeat the  2) and 4) but now fix the sample size to its orginal values and manipulate the effect size

# 5) How about trying the 3 groups function? What happends to power now?

power_one_source_3groups(Nmin = 50, # min sample size 
                         Nmax = 200, # max sample size
                         Nincrement = 50,  # increment in sample size
                         dmin = .2,  # min efefct size
                         dmax = .5,  # max effect size
                         dincrement = .1, # increment in effect size
                         n.iter = 1000) # number of iterations  
